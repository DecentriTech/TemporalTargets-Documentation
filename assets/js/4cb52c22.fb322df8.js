"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6638],{1970:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"API/Core Gameplay Logic/TemporalGameMode","title":"\ud83d\udcc4 File: TemporalGameMode.h","description":"Declares the ATemporalGameMode class for managing player respawn and ghost replay systems.","source":"@site/docs/API/Core Gameplay Logic/TemporalGameMode.md","sourceDirName":"API/Core Gameplay Logic","slug":"/API/_temporal_game_mode_8h","permalink":"/TemporalTargets-Documentation/docs/API/_temporal_game_mode_8h","draft":false,"unlisted":false,"editUrl":"https://github.com/DecentriTech/TemporalTargets-Documentation/tree/main/website/docs/API/Core Gameplay Logic/TemporalGameMode.md","tags":[],"version":"current","frontMatter":{"title":"\ud83d\udcc4 File: TemporalGameMode.h","slug":"/API/_temporal_game_mode_8h"},"sidebar":"tutorialSidebar","previous":{"title":"\ud83d\udcc4 File: TemporalCharacter.h","permalink":"/TemporalTargets-Documentation/docs/API/_temporal_character_8h"},"next":{"title":"Gameplay Data Assets","permalink":"/TemporalTargets-Documentation/docs/API/Gameplay-Data-Assets"}}');var a=s(4848),t=s(8453);const o={title:"\ud83d\udcc4 File: TemporalGameMode.h",slug:"/API/_temporal_game_mode_8h"},l="\ud83d\udcc4 File: TemporalGameMode.h",i={},c=[];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,t.R)(),...e.components},{Details:s,ExpandableCodeBlock:r}=n;return s||h("Details",!0),r||h("ExpandableCodeBlock",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsxs)(n.h1,{id:"-file-temporalgamemodeh",children:["\ud83d\udcc4 File: ",(0,a.jsx)(n.code,{children:"TemporalGameMode.h"})]})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["Declares the ",(0,a.jsx)(n.a,{href:"#class_a_temporal_game_mode",children:"ATemporalGameMode"})," class for managing player respawn and ghost replay systems."]}),"\n"]}),"\n",(0,a.jsxs)(s,{open:!0,children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)("summary",{children:"\ud83d\udcdd Detailed Description"}),"\r\nThis file defines the core game mode class for handling:"]}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Recording and storing player frame data for replays."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Spawning and tracking ghost characters with AI controllers."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Exposing Blueprint functions for managing ghost lifecycles and respawn flow."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Configuring delayed vs instant respawn based on gameplay mode."}),"\n"]}),"\n"]}),(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"#group___game___logic",children:"Core Gameplay Logic"})})]}),"\n",(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83d\udcd8 Class ",(0,a.jsx)(n.code,{children:"ATemporalGameMode"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Game mode handling player respawning and ghost replay logic."})]})}),(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Records the player's run into an array of ",(0,a.jsx)(n.a,{href:"#struct_f_player_frame_data",children:"FPlayerFrameData"})," frames."]}),"\n"]}),"\n"]}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:'Spawns ghost actors that reproduce previous runs ("replays").'}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Exposes Blueprint utilities for clearing, registering and querying ghosts."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Owns the respawn timer logic (instant vs delayed respawn controlled by ",(0,a.jsx)(n.a,{href:"#class_a_temporal_game_mode_1a196e99b79778bd0d825457c33a27988c",children:"bPlayMode"}),")."]}),"\n"]}),"\n"]}),(0,a.jsxs)(s,{open:!0,children:[(0,a.jsx)("summary",{children:"\ud83e\uddcd Members"}),(0,a.jsxs)(s,{open:!0,children:[(0,a.jsx)("summary",{children:"\u2699\ufe0f Functions"}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"ATemporalGameMode"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-func",children:"Public"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Default constructor."})]})}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"Parameters:"})," None"]}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 21\u201330)"]}),(0,a.jsx)(r,{code:'ATemporalGameMode::ATemporalGameMode()\n{\n  UE_LOG(LogTemp, Warning, TEXT("Emptied Stored Replays!"));\n\nStoredReplays.Empty();\n\nHUDClass = AGameHUD::StaticClass(); // Set the HUD class to your custom HUD\n\n  PlayerControllerClass = ATAPlayerController::StaticClass();\n}',language:"cpp",previewLines:15})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"~ATemporalGameMode"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-func",children:"Public"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Virtual destructor - cleans up timers & weak ptr maps."})]})}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"Parameters:"})," None"]}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 32\u201338)"]}),(0,a.jsx)(r,{code:"ATemporalGameMode::~ATemporalGameMode()\n{\n// Clear any remaining ghosts\nClearGhosts();\n\n  StoredReplays.Empty(); // TSharedPtr automatically handles cleanup\n}",language:"cpp",previewLines:15})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"AddReplayData"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-func",children:"Public"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Stores a replay attempt at the end of a run."})]})}),(0,a.jsx)("p",{children:(0,a.jsx)("strong",{children:"Parameters:"})}),(0,a.jsx)("ul",{children:(0,a.jsxs)("li",{children:[(0,a.jsx)("code",{children:"const TArray<  > & ReplayData"})," \u2013 Array of  containing the entire run."]})}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 161\u2013209)"]}),(0,a.jsx)(r,{code:'void ATemporalGameMode::AddReplayData(const TArray<FPlayerFrameData>& ReplayData)\n{\n  if (ReplayData.Num() == 0)\n  {\n      UE_LOG(LogTemp, Warning, TEXT("Attempted to store an empty replay!"));\n      return;\n  }\n\n  // Limit the maximum number of stored replays\n  const int32 MaxStoredReplays = 50;\n  if (StoredReplays.Num() >= MaxStoredReplays)\n  {\n      UE_LOG(LogTemp, Warning, TEXT("Exceeded max stored replays (%d), removing oldest."), MaxStoredReplays);\n      StoredReplays.RemoveAt(0); // TSharedPtr auto-cleans memory\n  }\n\n  // Store replay using shared pointer to prevent copies\n  TSharedPtr<FReplayAttempt> NewAttempt = MakeShared<FReplayAttempt>(ReplayData);\n  StoredReplays.Add(NewAttempt);\n\n  // 3) Clear out the player\'s recorder buffer so it starts fresh next life\n  if (APlayerController* PC = UGameplayStatics::GetPlayerController(this, 0))\n  {\n      if (ATACharacter* PlayerChar = Cast<ATACharacter>(PC->GetPawn()))\n      {\n          if (UReplayRecorderComponent* Recorder = PlayerChar->FindComponentByClass<UReplayRecorderComponent>())\n          {\n              Recorder->RecordedFrames.Empty();\n              UE_LOG(LogTemp, Log, TEXT("Cleared RecordedFrames on player\'s ReplayRecorder"));\n          }\n          else\n          {\n              UE_LOG(LogTemp, Warning,\n                  TEXT("AddReplayData: Player pawn has no ReplayRecorderComponent!")\n              );\n          }\n      }\n      else\n      {\n          UE_LOG(LogTemp, Warning,\n              TEXT("AddReplayData: Could not cast PlayerController->GetPawn() to ATACharacter")\n          );\n      }\n  }\n  else\n  {\n      UE_LOG(LogTemp, Warning, TEXT("AddReplayData: No local PlayerController found"));\n  }\n}',language:"cpp",previewLines:15})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"SpawnGhosts"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-func",children:"Public"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Spawns ghost pawns for every stored replay attempt."})]})}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"Parameters:"})," None"]}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 211\u2013281)"]}),(0,a.jsx)(r,{code:'void ATemporalGameMode::SpawnGhosts()\n{\n  // Log memory before spawning ghosts\n  FPlatformMemoryStats MemStatsBefore = FPlatformMemory::GetStats();\n  UE_LOG(LogTemp, Warning, TEXT("Memory BEFORE spawning ghosts: Used: %.2f MB | Peak: %.2f MB | Allocated: %.2f MB"),\n      MemStatsBefore.UsedPhysical / 1048576.0f, // Convert bytes to MB\n      MemStatsBefore.PeakUsedPhysical / 1048576.0f,\n      MemStatsBefore.TotalPhysical / 1048576.0f);\n\n  // Clear any previous ghosts.\n  ClearGhosts();\n\n  if (!TemporalCharacterClass)\n  {\n      UE_LOG(LogTemp, Warning, TEXT("TemporalCharacterClass not set in GameMode."));\n      return;\n  }\n\n  UWorld* World = GetWorld();\n  if (!World)\n  {\n      return;\n  }\n\n  // Loop through stored replays and spawn a ghost for each attempt.\n  for (const TSharedPtr<FReplayAttempt>& ReplayAttempt : StoredReplays)\n  {\n      if (!ReplayAttempt.IsValid() || !ReplayAttempt->ReplayDataPtr || ReplayAttempt->ReplayDataPtr->Num() == 0)\n      {\n          continue;\n      }\n\n      TArray<FPlayerFrameData>* SafeReplayData = ReplayAttempt->ReplayDataPtr.Get();\n      if (!SafeReplayData || SafeReplayData->Num() == 0)\n      {\n          continue;\n      }\n\n      // Spawn at the initial recorded location.\n      FVector SpawnLocation = (*SafeReplayData)[0].Position;\n      FRotator SpawnRotation = (*SafeReplayData)[0].Rotation;\n      FActorSpawnParameters SpawnParams;\n\n      ATemporalCharacter* NewGhost = World->SpawnActor<ATemporalCharacter>(TemporalCharacterClass, SpawnLocation, SpawnRotation, SpawnParams);\n      ATemporalAIController* GhostController = GetWorld()->SpawnActor<ATemporalAIController>();\n      \n\n      if (NewGhost && GhostController)\n      {\n          GhostController->Possess(NewGhost);\n          SpawnedControllers.Add(GhostController);\n\n          NewGhost->GhostID = ReplayAttempt->AssignedGhostID;\n\n          RegisterGhost(ReplayAttempt->AssignedGhostID, NewGhost);\n\n          NewGhost->InitializeGhostPlayback(ReplayAttempt->ReplayDataPtr);\n          SpawnedGhosts.Add(NewGhost);\n      }\n  }\n\n  ResolveHitGhosts();\n\n  // Log memory after spawning ghosts\n  FPlatformMemoryStats MemStatsAfter = FPlatformMemory::GetStats();\n  UE_LOG(LogTemp, Warning, TEXT("Memory AFTER spawning ghosts: Used: %.2f MB | Peak: %.2f MB | Allocated: %.2f MB"),\n      MemStatsAfter.UsedPhysical / 1048576.0f,\n      MemStatsAfter.PeakUsedPhysical / 1048576.0f,\n      MemStatsAfter.TotalPhysical / 1048576.0f);\n}',language:"cpp",previewLines:15})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"ClearGhosts"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-func",children:"Public"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Clears all spawned ghost actors and any stored replay attempts."})]})}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"Parameters:"})," None"]}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 283\u2013353)"]}),(0,a.jsx)(r,{code:'void ATemporalGameMode::ClearGhosts()\n{\n  UE_LOG(LogTemp, Warning, TEXT("Clearing %d ghosts"), SpawnedGhosts.Num());\n\n  for (ATemporalAIController* Controller : SpawnedControllers)\n  {\n      if (IsValid(Controller))\n      {\n          Controller->UnPossess();\n          Controller->Destroy();\n      }\n  }\n  SpawnedControllers.Empty();\n  SpawnedControllers.Shrink();\n\n  GhostRegistry.Empty();\n  GhostRegistry.Shrink();\n\n  // Destroy any spawned ghost actors\n  for (ATemporalCharacter* Ghost : SpawnedGhosts)\n  {\n      if (IsValid(Ghost))\n      {\n          // Unpossess the ghost if it has a controller\n          if (AController* Controller = Ghost->GetController())\n          {\n              Controller->UnPossess();\n          }\n\n          Ghost->Destroy();\n      }\n  }\n  SpawnedGhosts.Empty();\nSpawnedGhosts.Shrink();\n\n  if (StoredReplays.Num() > 52)\n  {\n      // Explicitly clear stored replay pointers\n      for (TSharedPtr<FReplayAttempt>& Replay : StoredReplays)\n      {\n          Replay.Reset();  // Clear shared pointer references\n      }\n\n      StoredReplays.Empty();\n      StoredReplays.Shrink();\n  }\n\n  // **Only force GC if memory usage is too high**\n  float MemoryUsedMB = FPlatformMemory::GetStats().UsedPhysical / 1048576.0f; // Convert bytes to MB\n  if (!IsGarbageCollecting())\n  { \n      if (MemoryUsedMB > 5000.0f)  // Example: If used memory > 5000MB\n      {\n          UE_LOG(LogTemp, Warning, TEXT("Memory exceeds threshold (%.2f MB). Forcing Garbage Collection..."), MemoryUsedMB);\n          CollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS, true);\n      }\n    else if (GEngine)\n      {\n          UE_LOG(LogTemp, Warning, TEXT("Performing normal Unreal GC."));\n          GEngine->ForceGarbageCollection(true);\n      }\n  }\n\n  // Check memory stats after clearing\n  FPlatformMemoryStats MemStatsAfterClear = FPlatformMemory::GetStats();\n  UE_LOG(LogTemp, Warning, TEXT("Memory AFTER clearing ghosts: Used: %.2f MB | Peak: %.2f MB | Allocated: %.2f MB"),\n      MemStatsAfterClear.UsedPhysical / 1048576.0f,\n      MemStatsAfterClear.PeakUsedPhysical / 1048576.0f,\n      MemStatsAfterClear.TotalPhysical / 1048576.0f);\n}',language:"cpp",previewLines:15})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"RegisterGhost"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-func",children:"Public"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Registers a ghost character instance so it can be retrieved later."})]})}),(0,a.jsx)("p",{children:(0,a.jsx)("strong",{children:"Parameters:"})}),(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:[(0,a.jsx)("code",{children:"FName GhostID"})," \u2013 Unique identifier (usually run index or GUID)."]}),(0,a.jsxs)("li",{children:[(0,a.jsx)("code",{children:"* Ghost"})," \u2013 Instantiated ghost character to track."]})]}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 355\u2013362)"]}),(0,a.jsx)(r,{code:'void ATemporalGameMode::RegisterGhost(FName GhostID, ATemporalCharacter* Ghost)\n{\n  if (!GhostID.IsNone() && IsValid(Ghost))\n  {\n      GhostRegistry.FindOrAdd(GhostID) = Ghost;\n      UE_LOG(LogTemp, Log, TEXT("Registered GhostID: %s"), *GhostID.ToString());\n  }\n}',language:"cpp",previewLines:15})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"GetGhostByID"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-func",children:"Public"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Retrieves a ghost character by its identifier."})]})}),(0,a.jsx)("p",{children:(0,a.jsx)("strong",{children:"Parameters:"})}),(0,a.jsx)("ul",{children:(0,a.jsxs)("li",{children:[(0,a.jsx)("code",{children:"FName GhostID"})," \u2013 Unique identifier used in ."]})}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 364\u2013374)"]}),(0,a.jsx)(r,{code:"ATemporalCharacter* ATemporalGameMode::GetGhostByID(FName GhostID) const\n{\n\n// Check if the GhostID is valid and exists in the registry\n  if (const TWeakObjectPtr<ATemporalCharacter>* Found = GhostRegistry.Find(GhostID))\n  {\n      return Found->IsValid() ? Found->Get() : nullptr;\n  }\n\n  return nullptr;\n}",language:"cpp",previewLines:15})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"PostLogin"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-protected-func",children:"Protected"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Binds death events when a new player joins."})]})}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"Parameters:"})," None"]}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 40\u201351)"]}),(0,a.jsx)(r,{code:"void ATemporalGameMode::PostLogin(APlayerController* NewPlayer)\n{\n  Super::PostLogin(NewPlayer);\n\n  if (APawn* Pawn = NewPlayer->GetPawn())\n  {\n      if (UDamageableComponent* Dmg = Pawn->FindComponentByClass<UDamageableComponent>())\n      {\n          Dmg->OnDeath.AddUniqueDynamic(this, &ATemporalGameMode::HandlePlayerDeath);\n      }\n  }\n}",language:"cpp",previewLines:15})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"RestartPlayer"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-protected-func",children:"Protected"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Restarts player with ghost-aware logic."})]})}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"Parameters:"})," None"]}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 53\u201374)"]}),(0,a.jsx)(r,{code:'void ATemporalGameMode::RestartPlayer(AController* NewPlayer)\n{\n  Super::RestartPlayer(NewPlayer);\n\n  if (APawn* Pawn = NewPlayer->GetPawn())\n  {\n      if (UDamageableComponent* DamageComp = Pawn->FindComponentByClass<UDamageableComponent>())\n      {\n          // Make sure we don\'t bind twice\n          DamageComp->OnDeath.RemoveDynamic(this, &ATemporalGameMode::HandlePlayerDeath);\n          DamageComp->OnDeath.AddUniqueDynamic(this, &ATemporalGameMode::HandlePlayerDeath);\n      }\n      else\n      {\n          UE_LOG(LogTemp, Error, TEXT("ATemporalGameMode: pawn %s has no UDamageableComponent!"), *Pawn->GetName());\n      }\n  }\n  else\n  {\n      UE_LOG(LogTemp, Error, TEXT("ATemporalGameMode: RestartPlayer spawned no pawn for %s"), *NewPlayer->GetName());\n  }\n}',language:"cpp",previewLines:15})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"ResolveHitGhosts"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-function",children:"function"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-protected-func",children:"Protected"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Checks recent hits against active ghosts and resolves collisions."})]})}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"Parameters:"})," None"]}),(0,a.jsx)("hr",{}),(0,a.jsxs)("p",{children:[(0,a.jsx)("strong",{children:"\ud83d\udcc4 Source:"})," ",(0,a.jsx)("code",{children:"Source/TimeAssassin/TemporalGameMode.cpp"})," (lines 376\u2013404)"]}),(0,a.jsx)(r,{code:'void ATemporalGameMode::ResolveHitGhosts()\n{\n  for (const TSharedPtr<FReplayAttempt>& Attempt : StoredReplays)\n  {\n      if (!Attempt.IsValid() || !Attempt->ReplayDataPtr) continue;\n\n      for (FPlayerFrameData& Frame : *Attempt->ReplayDataPtr)\n      {\n          if (!Frame.HasAction(EReplayActionFlags::FiredWeapon)) continue;\n\n          for (FRecordedShot& Shot : Frame.CombatData.Shots)\n          {\n              if (!Shot.HitGhostID.IsNone() && !Shot.HitActor.IsValid())\n              {\n                  if (ATemporalCharacter* Ghost = GetGhostByID(Shot.HitGhostID))\n                  {\n                      Shot.HitActor = Ghost;\n\n                      UE_LOG(LogTemp, Log, TEXT("Resolved Shot [%d]: HitGhostID %s to actor %s from instigator %s"), Shot.ShotIndex, *Shot.HitGhostID.ToString(), *GetNameSafe(Ghost), *GetNameSafe(GetGhostByID(Attempt->AssignedGhostID)));\n                  }\n                  else\n                  {\n                      UE_LOG(LogTemp, Error, TEXT("Failed to resolve HitGhostID %s"), *Shot.HitGhostID.ToString());\n                  }\n              }\n          }\n      }\n  }\n}',language:"cpp",previewLines:15})]})]}),(0,a.jsxs)(s,{open:!0,children:[(0,a.jsx)("summary",{children:"\ud83d\udce6 Variables"}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"bPlayMode"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-variable",children:"variable"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-attrib",children:"Public"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"If true, we play with ghosts + delayed respawn."})]})}),(0,a.jsx)("p",{children:"If true, we play with ghosts + delayed respawn."})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"RespawnDelay"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-variable",children:"variable"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-attrib",children:"Public"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Amount of time (seconds) after death before we respawn the player."})]})}),(0,a.jsx)("p",{children:"Amount of time (seconds) after death before we respawn the player."})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"RespawnTimerHandle"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-variable",children:"variable"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-public-attrib",children:"Public"}),"\r\n",(0,a.jsxs)("span",{class:"brief-description-pill",children:["Handle used by ",(0,a.jsx)(n.a,{href:"#class_a_temporal_game_mode_1a2f20687efa9847159c5e8b6504a1d1c9",children:"RespawnTimerHandle"})," to track the delayed respawn timer."]})]})}),(0,a.jsxs)("p",{children:["Handle used by ",(0,a.jsx)(n.a,{href:"#class_a_temporal_game_mode_1a2f20687efa9847159c5e8b6504a1d1c9",children:"RespawnTimerHandle"})," to track the delayed respawn timer."]})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"TemporalCharacterClass"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-variable",children:"variable"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-protected-attrib",children:"Protected"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Blueprint class used when spawning ghost characters."})]})}),(0,a.jsx)("p",{children:"Blueprint class used when spawning ghost characters."})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"SpawnedGhosts"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-variable",children:"variable"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-protected-attrib",children:"Protected"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Array storing spawned ghost actors so they can be managed & cleared."})]})}),(0,a.jsx)("p",{children:"Array storing spawned ghost actors so they can be managed & cleared."})]}),(0,a.jsxs)(s,{children:[(0,a.jsx)("summary",{children:(0,a.jsxs)(n.p,{children:["\ud83e\udde0 ",(0,a.jsx)("code",{children:"GhostRegistry"}),"\r\n",(0,a.jsx)("span",{class:"member-badge kind-variable",children:"variable"}),"\r\n",(0,a.jsx)("span",{class:"member-badge section-protected-attrib",children:"Protected"}),"\r\n",(0,a.jsx)("span",{class:"brief-description-pill",children:"Map of GhostID -> Ghost weak pointer for quick lookup without preventing GC."})]})}),(0,a.jsx)("p",{children:"Map of GhostID -> Ghost weak pointer for quick lookup without preventing GC."})]})]})]})]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}function h(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(6540);const a={},t=r.createContext(a);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);